# ------------------------------------------------------------------------------
#
# Copyright (c) 2013 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------

import time
import prman
arglist = []
prman.Init(arglist)
ri = prman.Ri()

max = 361
if max > 0:
    print "initializing re-rendering...."

    # Launch a prman process with a control channel
    filename = "launch:prman? -ctrl $ctrlin $ctrlout -xcpt $xcptin"
    #filename = "launch:prman? -ctrl $ctrlin $ctrlout -xcpt $xcptin -dspyserver it"
    ri.Begin(filename)

    # It's preferable to not use 'it' as your framebuffer.
    # The higher performance option is 'multires'.
    #ri.Display("rerender_light", "it", "rgba")
    ri.Display("rerender_light", "multires", "rgba")

    ri.Hider("raytrace", {"string integrationmode" :"path",
                          "int incremental" : 1,
                          "int maxsamples" : 64})

    # Load the baked scene
    ri.EditWorldBegin("scene.rib", {"string rerenderer" : "raytrace",
                                    "int[2] lodrange" : [0, 0]})

    # Wait for the load and it's initial display before
    # issuing edits.
    #print "waiting for initial display of editing session...."
    #time.sleep(5)

    # Rotate the area light
    print "now we're ready to send edits...."
    for i in range(1,max,10):
        # We can interrupt rendering by annotating the ri
        # stream and flushing the renderer to the desired
        # edit. We mark a point in the stream with a special
        # archive record.
        print "edit %d/%d" % (i,max)

        marker = "light_edits_" + `i`
        ri.ArchiveRecord("structure", ri.STREAMMARKER + marker );
        prman.RicFlush( marker, 0, ri.SUSPENDRENDERING)

        # Rotate area light
        ri.EditBegin("attribute", {"string scopename": "arealight1"})
        ri.Identity()
        ri.Rotate(i, 0, 1, 0)
        ri.Rotate(45, 1, 0, 0)
        ri.Translate(0,0,-12)
        ri.EditEnd()

        time.sleep(.5)
        # Give the renderer time to complete a few levels of
        # refinement before we interrupt it with a new edit.
        pg = prman.RicGetProgress()
        while pg < 2:
            time.sleep(.5)
            pg = prman.RicGetProgress()

    # wait for the end
    ri.ArchiveRecord("structure", ri.STREAMMARKER + "_end")
    prman.RicFlush("_end", 1, ri.FINISHRENDERING)

    print "now we're done editing"
    ri.EditWorldEnd()

    print "editing done, goodbye"
    ri.End()
