/* 
   <meta id="RMSSTAMP">
    Creator RfM 5.5b2 (@1222788 Sep 11 2013)
    For gharker
    CreationDate Wed Sep 25 17:18:36 2013
  </meta>
*/

/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 2012 Pixar Animation Studios. All rights reserved.
#
# The information in this file (the "Software") is provided for the
# exclusive use of the software licensees of Pixar.  Licensees have
# the right to incorporate the Software into other products for use
# by other authorized software licensees of Pixar, without fee.
# Except as expressly permitted herein, the Software may not be
# disclosed to third parties, copied or duplicated in any form, in
# whole or in part, without the prior written permission of
# Pixar Animation Studios.
#
# The copyright notices in the Software and this entire statement,
# including the above license grant, this restriction and the
# following disclaimer, must be included in all copies of the
# Software, in whole or in part, and all permitted derivative works of
# the Software, unless such copies or derivative works are solely
# in the form of machine-executable object code generated by a
# source language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

/*
 * RMSGPSurface.sl  $Revision: #9 $
 *  a GeneralPurpose Surface Shader that supports layered physically plausible
 *  shading and subsurface scattering.
 */

/*
*/

#define DEBUG 0

#define ISBASESHADER() (this == surface)

// RSLINJECT_preamble
#include <customNodes/_rmsGPSurface.h>
#include <customNodes/_rmsDisplacement.h>


// RSLINJECT_shaderdef
class
siggraph_glassBottlesOnCakeStand_v03_RMSMatte1_rfm
(
    uniform color surfaceColor=color(1, 1, 1);
    uniform float diffuseGain=1;
    uniform color translucentColor=color(0, 0, 0);
    uniform float diffuseRoughness=0;
    uniform color emission=color(0, 0, 0);
    uniform float emissionExposure=0;
    uniform float distributionAngle=90;
    uniform float __computesOpacity=0;
    uniform float dispMode=1;
    uniform float compositionRule=1;
    uniform color sssTint=color(1, 1, 1);
    uniform color sssMix=color(0, 0, 0);
    uniform float sssDmfpScale=1;
    uniform color sssDmfp=color(1, 1, 1);
    uniform float sssSamples=16;
    uniform float ior=1.5;
    uniform string sssPassID="RenderCam_SSRender";
    uniform string sssConversionClass="SSDiffuse";
    uniform string sssOutputFile="";
    uniform string sssMap="";
    uniform string sssMapConnection="";
    uniform string sssSpace="world";
    uniform string __group="";
    uniform string lightGroups[]={};
    uniform string __category="RMSGPLayer,stdrsl_plausible";
    uniform string SurfaceMap="";
    uniform string DisplacementMap="";
    uniform string MaskMap="";
    uniform string shadowname="";
    uniform float traceShadows=1;
    uniform float adaptive=1;
    uniform string subset="";
    uniform string excludesubset="";
    uniform float bias=-1;
    uniform float mapbias=1;
    uniform float mapbias2=1;
)
{
    // All member variables are deemed private
    rms_GPSurface m_gpsurf;

    // RSLINJECT_members
    #define bumpEncoding 1
    #define sssSmooth 0
    #define giSamplesOverride -1
    #define linearizeTint 0
    #define mask 1
    #define transparency color(0, 0, 0)
    #define indirectIrradiance 0
    #define enableDisplacement -1
    #define vectorEncoding 1
    #define displacementScalar 0
    #define displacementVector vector(0, 0, 0)
    #define displacementAmount 0
    #define normalEncoding 0
    #define normalMode -1
    #define inputNormal normal(0, 0, 0)
    #define displacementCenter 0.5
    #define bumpScalar 0
    #define bumpAmount 0
    #define lightCategory ""
    #define purity 0.002
    #define useCs 1
    #define applySRGB 1
    #define sssAlbedo color(1, 1, 1)
    #define sssUnitlen 0.1
    #define sssMaxDepth 2
    #define sssTraceSet ""
    #define sssMaxDist 10

    public void construct()  
        // no parameter dependencies, so no INJECT
    {
        m_gpsurf->Construct(); 
    }

    public void begin() 
        // depends on mask settings
        // guaranteed to run in coshaders prior to any method invocations
    {
        // RSLINJECT_begin
        if(ISBASESHADER()) 
        {
            // RMSMatte doesn't support layering, only standalone or
            // atop a GPSurface base.
            shader boundLayers[] = {}; 
            color opacity = mask * 
                            (color(1) - clamp(transparency,color(0),color(1)));
            m_gpsurf->Begin(boundLayers, opacity, MaskMap, 0,0,0,0, indirectIrradiance, 0, null);
        }
    }
 
    public void opacity(output color Oi)
    {
        Oi = m_gpsurf->m_opacity;
    }

    // displacement:
    //  the displacement method is only called on the BASESHADER
    //  we delegate to coshaders variant method ComputeLayerDisplacement
    //
    public void displacement(output point P; output normal N) 
    {
        m_gpsurf->DelegateDisplacement(enableDisplacement, dispMode, P, N);
    }

    public void prelighting(output color Ci, Oi) 
    {
        // RSLINJECT_prelighting
        if(this == surface)
        m_gpsurf->DelegatePrelighting(emission, distributionAngle, emissionExposure,
                                      traceShadows, adaptive, bias, mapbias, 
                                      mapbias2, shadowname, subset, 
                                      excludesubset);
    }

    // initDiffuse: shared initialization function for diffuse.
    //
    private color initDiffuse() 
    {
        // RSLINJECT_initDiffuse

        if(ISBASESHADER() && useCs == 1)
        {
            m_gpsurf->InitDiffuse(surfaceColor*Cs, SurfaceMap, translucentColor,
                              applySRGB, purity, diffuseRoughness, diffuseGain,
                              0);
        }
        else
        {
            m_gpsurf->InitDiffuse(surfaceColor, SurfaceMap, translucentColor,
                              applySRGB, purity, diffuseRoughness, diffuseGain,
                              0 );
        }
        return m_gpsurf->m_diffuse->m_diffColor;
    }

    // The base shader lighting methods -----------------------------------
    // diffuselighting:
    //   automatically called on base shader on ray-shaded points
    //   we delegate to coshader DiffuselightingCS method
    //
    public void diffuselighting(output color Ci, Oi, Ii) 
    {
        // RSLINJECT_diffuselighting

        color specContribution;
        if(m_gpsurf->BaseIsVisible(specContribution) == 1)
        {
            initDiffuse();
        }
        Ci = m_gpsurf->DelegateDiffuseLighting(lightCategory, lightGroups,
                           ior, 0, sssAlbedo, sssTint, sssDmfp * sssDmfpScale,
                           sssUnitlen, sssSamples, sssMix, sssTraceSet, 
                           sssMaxDist, sssMaxDepth, 
                           sssPassID, sssConversionClass,
                           sssOutputFile, sssMap, sssSpace, 
                           giSamplesOverride, Ii);
    }

    // we don't have a specularlighting method since we are pure-diffuse
    // we *do* have an InitLayerSpecular since base shader protocol requires it

    // evaluateSamples:
    //  called by directlighting 
    //  base shader delegates to EvaluateLayerSamples method on coshaders
    //
    public void evaluateSamples(string distribution;
                                output __radiancesample samples[])
    {
        // no injection required since we have no data dependencies
        m_gpsurf->DelegateEvaluateSamples(distribution, samples);
    }

    public void postlighting(output varying color Ci, Oi)
    {
        m_gpsurf->DelegatePostLighting(Ci,Oi);
    }
    public void generateSamples(string type; output __radiancesample samples[];)
    {
        float roughnessVals[];
        m_gpsurf->DelegateGenerateSamples(type, samples, roughnessVals);
    }
    /*---------------------------------------------------------------*/
    // InitCoshader:
    //  a special coshader interface method to ensure synchronization
    //  of shading context and layering with base shader.
    //  May be called twice when displacements are in play.
    public void InitCoshader(stdrsl_ShadingContext ctx; 
                             output color omask;
                             output uniform float omaskReflections;)
        // depends on mask parameters
    {
        m_gpsurf->m_shadingCtx = ctx; // precedes RSLINJECT

        // RSLINJECT_InitCoshader

        color opacity = mask * (color(1) - clamp(transparency,color(0),color(1)));
        m_gpsurf->InitMask(opacity, MaskMap);

        omask = m_gpsurf->m_mask;
        omaskReflections = 0;

    }

    // ComputeLayerDisplacement:
    //  a special coshader interface for displacement composition
    //  called via baseshader->displacement->ComputeDisplacement
    public void ComputeLayerDisplacement(point origP; 
                                         normal origN; 
                                         output point accumP; 
                                         output normal accumN)

    {
        // RSLINJECT_displacement
        rms_Displacement disp;
        disp->ComputeLayerDisplacement(origP, origN, accumP, accumN,
                                          mask,
                                          dispMode, vectorEncoding, 
                                          normalEncoding,
                                          displacementScalar, 
                                          displacementVector, 
                                          DisplacementMap, 
                                          displacementAmount, 
                                          displacementCenter,
                                          normalMode, inputNormal,
                                          compositionRule,
                                          bumpScalar, bumpAmount,
                                          bumpEncoding);

    }

    // The coshader lighting methods -----------------------------------
    // Simplified methods that need only return data to the base shader 
    // for evaluation. Only called via delegation from base shader.
    public void InitLayerDiffuse(output color diffuseColor;
                                 output color SssAlbedo, SssTint, SssDmfp, SssMix;
                                 output float SssUnitlen,SssSamples;)
    {
        SssTint = sssTint;
        SssAlbedo = sssAlbedo;
        SssDmfp = sssDmfp * sssDmfpScale;
        SssMix = sssMix;
        SssUnitlen = sssUnitlen;
        SssSamples = sssSamples;

        diffuseColor = initDiffuse();
    }


    public void InitLayerSpecular(color specContribution; output float Kt)
    {
        Kt = 1; // we're not specular, so our job is rather simple
    }

    public void InitLayerSpecAndDiffuse(color specContribution;
                                        output color diffuseColor;
                                        output float Kt;
                                        output color SssAlbedo, SssTint, SssDmfp, SssMix;
                                        output float SssUnitlen,SssSamples;
                                        )
    {
        Kt = 1;
        InitLayerDiffuse(diffuseColor, SssTint, SssAlbedo, SssDmfp,
                         SssMix, SssUnitlen, SssSamples);
    }


    public void EvaluateLayerSamples(string distribution;
                                color layerContrib;
                                output __radiancesample samples[])
    {
        m_gpsurf->EvaluateLayerSamples(distribution, layerContrib, samples);
    }

    public void GenerateLayerSamples(string type; 
                                output __radiancesample samples[];
                                output float roughnessVals[];
                                output uniform float counts[])
    {
        m_gpsurf->GenerateLayerSamples(type,samples,roughnessVals,counts);
    }

    public void UpdateLayerManifold(point PP; normal NN)
    {
        m_gpsurf->m_shadingCtx->m_Ps = PP;
        m_gpsurf->m_shadingCtx->m_Nn = NN;
        m_gpsurf->m_shadingCtx->reinit();
    }

    //Method for evaluating the prelighting method on the coshader and 
    //returning incandescence behavior
    public void GetEmission(output color retIncand; output varying float retExposure)
    {
        //run the prelighting setup here just to return emission to 
        //the parent coshader
        // RSLINJECT_prelighting
        retIncand = emission;
        retExposure = emissionExposure;
    }
}
